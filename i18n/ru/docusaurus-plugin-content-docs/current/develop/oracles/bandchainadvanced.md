---
id: bandchainadvanced
title: Дополнительные возможности BandChain
sidebar_label: Advanced
description: Создайте свое следующее блокчейн-приложение на Polygon.
keywords:
  - docs
  - matic
image: https://matic.network/banners/matic-network-16x9.png
---
import useBaseUrl from '@docusaurus/useBaseUrl';

Смарт-контракты содержат набор логики, на основе которой работают децентрализованные приложения. Однако они не могут просто полагаться на пользовательский ввод, и для работы их логики требуется внешняя информация. BandChain предоставляет набор скриптов оракулов, которые можно использовать для связи с внешними web API. После получения данных из децентрализованной сети BandChain их можно использовать в децентрализованных приложениях по мере необходимости.

<img src={useBaseUrl("img/bandchain/bandchain.png")} />

Процесс целиком можно достаточно четко понять на основе описанной выше архитектуры. Первоначально в сеть BandChain направляется запрос. При получении ответа из сети произойдет небольшая задержка. Этот ответ необходимо сохранить в контракте подтверждения, который будет развернут в Polygon. Важно отметить, что этот контракт подтверждения отличается от контракта BandChain, который уже развернут в Polygon. Поэтому после развертывания этого контракта подтверждения данные ответа внешнего web API могут обновляться в переменной состояния в контракте подтверждения всегда, когда это требуется. Этот контракт подтверждения использует контракт BandChain для подтверждения сохраняемых в нем данных. Децентрализованные приложения могут запрашивать контракт подтверждения всегда, когда им требуется получить какие-либо данные из внешнего мира. Следующие шаги помогут лучше понять эту архитектуру.

**1.** **Выбор скрипта оракула**

Эти скрипты оракула необходимы для запроса внешних данных. Скрипты обеспечивают уникальную идентификацию данных, которые мы хотим запросить. Перейдите в [http://scan.alpha.bandchain.org](http://scan.alpha.bandchain.org/). Там вы найдете обозреватель с информацией о BandChain. Затем мы посетим страницу скриптов оракулов, воспользовавшись ссылкой в правом верхнем углу. Также вы можете непосредственно перейти к скриптам оракула по адресу [http://scan.alpha.bandchain.org/scripts](http://scan.alpha.bandchain.org/scripts). Здесь находится несколько встроенных скриптов оракула. Для разъяснения процесса мы используем пример генератора случайных чисел. Поэтому давайте нажмем на скрипт оракула генератора случайных чисел, который называется random_u64.

<img src={useBaseUrl("img/bandchain/oraclescripts.png")} />

**2. Выполнение скрипта**

При нажатии на скрипт выполняется переадресация на другую страницу, где можно увидеть детали этого скрипта. Скрипт будет иметь хэш-сумму ```0xe7944e5e24dc856dcb6d9926460926ec10b9b66cf44b664f9971b5a5e9255989```. В число других деталей входят последние транзакции, связанные со скриптом, код скрипта и вкладка под названием execute. Если мы перейдем на эту вкладку, мы сможем запустить этот скрипт. Вам нужно будет передать числовое значение в параметр max_range. Этот параметр указывает границы максимального диапазона ваших случайных чисел. В течение нескольких секунд после нажатия на запрос отправки генерируется хэш-сумма.

<img src={useBaseUrl("img/bandchain/executeoracle.png")} />

При нажатии на хэш происходит перенаправление на другую страницу, где отображается результат запроса. Здесь вам необходимо нажать на сообщение запроса данных, чтобы перейти на другую страницу, где вы сможете посмотреть полные детали ответа и доказательство действительности от BandChain. Также здесь отображается генерируемое случайное число вместе с временной меткой. Нажмите «Копировать доказательство для Ethereum» на вкладке «Доказательство действительности», чтобы генерировать полезную нагрузку, которая будет работать со всеми EVM-совместимыми блокчейнами, которые поддерживает BandChain. Эту полезную нагрузку следует использовать для обновления переменных состояния в контракте подтверждения.

<img src={useBaseUrl("img/bandchain/copyproof.png")} />

Это первый способ выполнить запрос к оракулу. Здесь мы использовали обозреватель. Существует и другой способ выполнения запросов, основанный на использовании REST API Bandchain.

Конечная точка API для выполнения запроса: [http://rpc.alpha.bandchain.org/bandsv/request](http://rpc.alpha.bandchain.org/bandsv/request). Децентрализованные приложения могут получать к ней доступ напрямую или использовать библиотеки клиентов HTTP, такие как axios. В этом примере мы используем инструмент под названием Postman, который очень полезен для тестирования конечных точек API. Его можно загрузить напрямую с сайта [https://www.postman.com](https://www.postman.com/). После загрузки вы можете установить приложение Postman и начать выполнять любые типы запросов HTTP. API запроса оракула представляет собой метод POST, принимающий параметры body в формате application/json. Обычно используются три параметра.

A. type — это параметр типа string, который может принимать значения "SYNCHRONOUS" | "ASYNCHRONOUS" | "FULL". При выполнении запросов из децентрализованных приложений мы рекомендуем использовать режим "FULL".

B. params — это параметры объектного типа. В примере с генератором случайных чисел потребуются такие параметры как {"max_range": "100"}.

C. codeHash: это параметр строкового типа, принимающий в качестве значения скрипт оракула. В нашем примере это поле будет иметь значение ```0xe7944e5e24dc856dcb6d9926460926ec10b9b66cf44b664f9971b5a5e9255989```. Обязательно удалите '0x' из скрипта оракула, если это не сделано.

В целом полезная нагрузка и запрос выглядят следующим образом:-

<img src={useBaseUrl("img/bandchain/requestapi.png")} />

Ответ на показанный выше запрос в Postman содержит случайное число, временную метку и доказательство действительности. В ответе также будет присутствовать поле evmProofBytes, содержащее полезную нагрузку, которая потребуется на следующем шаге для обновления переменных состояния в контракте подтверждения. Сценарий оракула и объект param в приведенном выше запросе можно заменить для выполнения запросов к разнообразным встроенным скриптам оракула.

**3. Использование данных в смарт-контрактах**

На этом шаге вы фактически сохраните данные в контракте подтверждения в Polygon. Перед сохранением вам потребуется развернуть контракт подтверждения. Этот контракт подтверждения будет выглядеть следующим образом.

```jsx
pragma solidity 0.5.14;
pragma experimental ABIEncoderV2;

import "BandChainLib.sol";
import "IBridge.sol";

contract RandomNumber {
    using BandChainLib for bytes;

    bytes32 public codeHash;
    bytes public params;
    IBridge public bridge;

    uint256 public randomNumber;
    uint256 public lastUpdate;

    constructor(bytes32 _codeHash, bytes memory _params, IBridge _bridge)
        public
    {
        codeHash = _codeHash;
        params = _params;
        bridge = _bridge;
    }

    function update(bytes memory _reportPrice) public {
        IBridge.VerifyOracleDataResult memory result = bridge.relayAndVerify(
            _reportPrice
        );
        uint64[] memory decodedInfo = result.data.toUint64List();

        require(result.codeHash == codeHash, "INVALID_CODEHASH");
        require(
            keccak256(result.params) == keccak256(params),
            "INVALID_PARAMS"
        );
        require(
            uint256(decodedInfo[1]) > lastUpdate,
            "TIMESTAMP_MUST_BE_OLDER_THAN_THE_LAST_UPDATE"
        );

        randomNumber = uint256(decodedInfo[0]);
        lastUpdate = uint256(decodedInfo[1]);
    }
}
```

Важно отметить, что этот контракт имеет две переменных состояния (randomNumber и lastUpdated) для сохранения значения случайного числа и временной метки последнего обновления соответственно. Контракт RandomNumber также должен импортировать BandChainLib.sol и IBridge.sol (библиотеки помощника и интерфейсы). Эти два помощника необходимы для создания контракта подтверждения. Их можно найти по ссылкам [https://docs.bandchain.org/references/bandchainlib-library](https://docs.bandchain.org/references/bandchainlib-library) и [https://docs.bandchain.org/references/ibridge-interface](https://docs.bandchain.org/references/ibridge-interface) соответственно.

После импорта этих двух файлов в основной контракт solidity вы можете перейти в remix и создать три файла solidity с именами RandomNumber.sol, IBridgesol и BandChainLib.sol с соответствующим содержимым. Для работы вышеуказанного примера следует изменить версию компилятора на 0.5.14. Скомпилируйте контракт и задайте RPC metamask так, чтобы он указывал на [https://testnetv3.matic.network](https://testnetv3.matic.network/), т. е. на тестовую сеть Polygon TestnetV3. Если у вас возникнут сложности при настройке metamask, следуйте указаниям этого [руководства](/docs/develop/metamask/config-polygon-on-metamask).

<img src={useBaseUrl("img/bandchain/cmpilecontract.png")} />

Следующий шаг после успешного завершения компиляции заключается в развертывании контракта RandomNumber. Этот контракт принимает 3 параметра в аргументах конструктора. Первый параметр — это параметр codeHash, принимающий в качестве значения хэш скрипта оракула. В нашем примере следует использовать ```0xe7944e5e24dc856dcb6d9926460926ec10b9b66cf44b664f9971b5a5e9255989``` в качестве значения хэша. Второй параметр — это параметр params, принимающий в качестве значения сериализованную строку параметров в качестве запроса оракула. Для получения этой сериализованной строки в байтовой форме Bandchain предоставляет API с конечной точкой [http://rpc.alpha.bandchain.org/zoracle/serialize_params/:codeHash](http://rpc.alpha.bandchain.org/zoracle/serialize_params/:codeHash). Это метод GET, который можно взять из клиентской библиотеки HTTP, такой как axios. В этом примере мы используем инструмент Postman для запуска данного API. ':codeHash' в URL можно заменить хэш-суммой скрипта оракула и передать объект param (конвертируемый в байты) как параметр запроса этой конечной точки, используя ключ params. Для этого примера запрос Postman GET выглядит следующим образом.

<img src={useBaseUrl("img/bandchain/bytesapi.png")} />

Значение полученного ключа из вышеуказанного ответа API можно конвертировать в шестнадцатеричный формат, просто добавив к нему 0x. В этом примере окончательное шестнадцатеричное значение будет выглядеть как 0x0000000000000064. Обратите внимание, что мы передали 100 как значение ключа max_range объекта params. Значение max_range должно совпадать со значением запроса оракула в шаге 2. Третий параметр — это мост, принимающий в качестве значения адрес контракта BandChain, который уже развернут в тестовой сети Polygon TestnetV3. Адрес контракта BandChain: ```0x3ba819b03fb8d34995f68304946eefa6dcff7cbf```.

<img src={useBaseUrl("img/bandchain/deploycontract.png")} />

Теперь контракт можно развернуть. После успешного завершения развертывания значение переменной состояния randomNumber можно обновлять по мере необходимости, используя метод обновления контракта. И здесь начинается главное волшебство BandChain. Функция обновления использует только один параметр bytes memory _reportPrice, использующий данные, которые мы запросили в BandChain. Если мы вернемся к шагу 2, мы увидим, что получили полезную нагрузку при запросе сети BandChain. Это будет значение evmProofBytes в объекте ответа. Его нужно будет конвертировать в шестнадцатеричный формат, добавив в его начало 0x. Это значение передается методу обновления контракта. На иллюстрации ниже мы видим, что randomNumber имеет начальное значение 59.

<img src={useBaseUrl("img/bandchain/update.png")} />

Далее нам требуется декодировать информацию запроса из _reportPrice. Для этого мы используем функцию IBridge.relayAndVerify, которая возвращает структуру IBridge.VerifyOracleDataResult, содержащую данные, codeHash и параметры запроса. Для чтения данных (в данном случае — случайного числа и временной метки) мы используем BandChainLib.toUint64List на байтах result.data.

Для проверки целостности данных мы проверяем соответствие codeHash и параметров запроса заданным в конструкторе. Наконец, мы должны убедиться, что контракт всегда будет обновлять цену с более новой временной меткой.

Мы декодировали данные, подтвердили их подлинность и проверили условие обновления значения случайного числа. Теперь мы можем обновить состояние смарт-контракта, используя значение случайного числа и временную метку, полученные от BandChain. После выполнения метода update мы видим, что значение randomNumber изменилось на 17.

<img src={useBaseUrl("img/bandchain/updated.png")} />

Теперь, когда нам потребуется случайное число, децентрализованное приложение должно обратиться к BandChain api «с теми же параметрами», получить новое доказательство evmProof и использовать его для обновления контракта подтверждения. Затем децентрализованное приложение сможет запрашивать контракт подтверждения для доступа к значению случайного числа. Каждый раз, когда переменные состояния обновляются, обновляемое значение подтверждается контрактом BandChain, который уже развернут в Polygon.

Этот пример был демонстрацией того, как можно сохранить и обновить значение случайного числа в случае необходимости. Децентрализованные приложения смогут использовать это значение для своей логики смарт-контрактов. Подобным образом можно создавать и другие контракты подтверждения для хранения нескольких значений. Bandchain предоставляет несколько встроенных скриптов оракула. Также вы можете использовать truffle для развертывания контракта подтверждения и web3 для взаимодействия с контрактом вместо использования remix.